unit TerminalThread;

interface

uses
  CPDrv,
  SysUtils,
  DateUtils,
  System.Classes,
  terminal,
  SyncObjs;

type
  TDataReceivedCallback = procedure(const Data: TArray<Byte>) of object;
  TCallbackFunction = procedure(const connect: boolean) of object;
  TTerminalThread = class(TThread)

  private
    { Private declarations }
    FConnectionCallBack: TCallbackFunction;
  protected
    FTerminateEvent: TEvent;
    procedure Execute; override;

  public
   TerminateEvent: TEvent;
    FCommPort: TCommPortDriver;
    FTerminal: Tterminal;
    FDataReceivedCallback: TDataReceivedCallback;
    procedure CommPortReceiveData(Sender: TObject; DataPtr: Pointer;  DataSize: Cardinal);
    constructor Create(ACommPort: TCommPortDriver = nil; DataReceivedCallback: TDataReceivedCallback = nil; ConnectionCallBack:TCallbackFunction = nil);
  end;

implementation

//Конструктор потока
constructor TTerminalThread.Create(
    ACommPort: TCommPortDriver = nil;
    DataReceivedCallback: TDataReceivedCallback = nil;
    ConnectionCallBack:TCallbackFunction = nil
);
begin
  inherited Create(True);
  FCommPort := ACommPort;
  FDataReceivedCallback := DataReceivedCallback;
  FConnectionCallBack := ConnectionCallBack;
  FTerminateEvent := TEvent.Create(nil, True, False, '');
  FTerminal := Tterminal.Create(FCommPort);
  FCommPort.OnReceiveData := CommPortReceiveData;
end;

//Приём данных
procedure TTerminalThread.CommPortReceiveData(Sender: TObject; DataPtr: Pointer;  DataSize: Cardinal);
var
  hexString: string;
  buf: TArray<byte>;
  connect: Boolean;
begin
  try
    connect := True;
    SetLength(buf, DataSize);
    Move(DataPtr^, buf[0], DataSize);
    if buf[1] = $F0 then Fterminal.stopBootloader;

    if Assigned(FDataReceivedCallback) then
      FDataReceivedCallback(buf);

    if Assigned(FConnectionCallBack) then
       FConnectionCallBack(connect);

  except
  on E: Exception do
    begin
 // Обработка исключения
//     sendMessage('Ошибка: ' + E.Message);
    end;
  end;
end;

//Поток
procedure TTerminalThread.Execute;
var   Data: Tbytes;
  DataPtr: Pointer;
  DataSize: Cardinal;
begin
  while not Terminated do
  begin
    Data :=[$FF,$FF,$F0,$FE];


    DataPtr := @Data[0];
    DataSize := SizeOf(Data);
    CommPortReceiveData(nil,  DataPtr, DataSize);

    if FCommPort.Connected then
    begin
      FTerminal.info;
      sleep(1000);
    end;
  end;
end;

end.
